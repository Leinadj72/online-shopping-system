To accommodate separate collections for men, women, and kids products, as well as to manage popular and related products separately, you’ll need to structure your backend and frontend accordingly. Here’s how you can approach this:
Backend Changes

    Modify the Product Schema: Add fields to categorize products into collections like popular and related.

javascript

const productSchema = new mongoose.Schema({
  id: {
    type: Number,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  image: {
    type: String,
    required: true,
  },
  category: {
    type: String,
    required: true,
    enum: ['women', 'men', 'kid'], // Enum to restrict categories
  },
  new_price: {
    type: Number,
    required: true,
  },
  old_price: {
    type: Number,
    required: true,
  },
  date: {
    type: Date,
    default: Date.now,
  },
  available: {
    type: Boolean,
    default: true,
  },
  popular: {
    type: Boolean,
    default: false,
  },
  related: [Number], // Array of related product IDs
});

    API Endpoints for Separate Collections:
        Add Product Endpoint: Adjust to include category and collections information.

javascript

app.post('/addproduct', async (req, res) => {
  try {
    const products = await Product.find({});
    const id = products.length > 0 ? products[products.length - 1].id + 1 : 1;

    const product = new Product({
      id,
      name: req.body.name,
      image: req.body.image,
      category: req.body.category,
      new_price: req.body.new_price,
      old_price: req.body.old_price,
      popular: req.body.popular || false,
      related: req.body.related || [],
    });

    await product.save();
    console.log('Product Saved:', product);
    res.json({ success: true, name: req.body.name });
  } catch (error) {
    console.error('Error adding product:', error);
    res.status(500).json({ success: false, message: 'Error adding product' });
  }
});

    Get Products by Category Endpoint:

javascript

app.get('/products/:category', async (req, res) => {
  try {
    const category = req.params.category;
    const products = await Product.find({ category: category });
    console.log(`Products in category ${category} fetched`);
    res.json(products);
  } catch (error) {
    console.error('Error fetching products by category:', error);
    res.status(500).json({ success: false, message: 'Error fetching products' });
  }
});

    Get Popular Products Endpoint:

javascript

app.get('/popularproducts', async (req, res) => {
  try {
    const products = await Product.find({ popular: true });
    console.log('Popular Products Fetched');
    res.json(products);
  } catch (error) {
    console.error('Error fetching popular products:', error);
    res.status(500).json({ success: false, message: 'Error fetching products' });
  }
});

    Get Related Products Endpoint:

javascript

app.get('/relatedproducts/:id', async (req, res) => {
  try {
    const product = await Product.findOne({ id: req.params.id });
    if (!product) {
      return res.status(404).json({ success: false, message: 'Product not found' });
    }

    const relatedProducts = await Product.find({ id: { $in: product.related } });
    console.log('Related Products Fetched');
    res.json(relatedProducts);
  } catch (error) {
    console.error('Error fetching related products:', error);
    res.status(500).json({ success: false, message: 'Error fetching products' });
  }
});

Frontend Changes

    Add New Product Form:

    Modify the form to include fields for selecting the category, whether the product is popular, and related product IDs.

jsx

const AddProduct = () => {
  const [image, setImage] = useState(null);
  const [productDetails, setProductDetails] = useState({
    name: '',
    image: '',
    category: 'women',
    new_price: '',
    old_price: '',
    popular: false,
    related: [],
  });

  const imageHandler = (e) => {
    setImage(e.target.files[0]);
  };

  const changeHandler = (e) => {
    setProductDetails({ ...productDetails, [e.target.name]: e.target.value });
  };

  const togglePopular = () => {
    setProductDetails({ ...productDetails, popular: !productDetails.popular });
  };

  const addProduct = async () => {
    let responseData;
    let product = productDetails;
    let formData = new FormData();
    formData.append('product', image);

    await fetch('http://localhost:4000/upload', {
      method: 'POST',
      headers: {
        Accept: 'application/json ',
      },
      body: formData,
    })
      .then((resp) => resp.json())
      .then((data) => {
        responseData = data;
      });

    if (responseData.success) {
      product.image = responseData.image_url;

      await fetch('http://localhost:4000/addproduct', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(product),
      }).then((resp) => resp.json())
        .then((data) => {
          console.log(data);
        });
    }
  };

  return (
    <div className="add-product">
      <div className="addproduct-itemfield">
        <p>Product title</p>
        <input
          value={productDetails.name}
          onChange={changeHandler}
          type="text"
          name="name"
          placeholder="Type here"
        />
      </div>
      <div className="addproduct-price">
        <div className="addproduct-itemfield">
          <p>Price</p>
          <input
            value={productDetails.old_price}
            onChange={changeHandler}
            type="text"
            name="old_price"
            placeholder="Type here"
          />
        </div>
        <div className="addproduct-itemfield">
          <p>Offer Price</p>
          <input
            value={productDetails.new_price}
            onChange={changeHandler}
            type="text"
            name="new_price"
            placeholder="Type here"
          />
        </div>
      </div>
      <div className="addproduct-itemfield">
        <p>Product Category</p>
        <select
          value={productDetails.category}
          onChange={changeHandler}
          name="category"
          className="add-product-selector"
        >
          <option value="women">Women</option>
          <option value="men">Men</option>
          <option value="kid">Kid</option>
        </select>
      </div>
      <div className="addproduct-itemfield">
        <label htmlFor="file-input">
          <img
            src={image ? URL.createObjectURL(image) : upload_area}
            className="addproduct-thumbnail-img"
            alt=""
          />
        </label>
        <input
          onChange={imageHandler}
          type="file"
          name="image"
          id="file-input"
          hidden
        />
      </div>
      <div className="addproduct-itemfield">
        <label>
          <input
            type="checkbox"
            checked={productDetails.popular}
            onChange={togglePopular}
          />
          Popular
        </label>
      </div>
      <div className="addproduct-itemfield">
        <p>Related Products (comma separated IDs)</p>
        <input
          value={productDetails.related}
          onChange={(e) => setProductDetails({ ...productDetails, related: e.target.value.split(',').map(id => parseInt(id.trim(), 10)) })}
          type="text"
          name="related"
          placeholder="Type here"
        />
      </div>
      <button
        onClick={addProduct}
        className="addproduct-btn"
      >
        ADD
      </button>
    </div>
  );
};

export default AddProduct;

    Display Products by Category:

    Implement UI components to display products based on categories like men, women, and kids. You can create separate pages or sections.

    Display Popular Products:

    Create a section in your admin dashboard to view and manage popular products.

    Display Related Products:

    Implement a component to fetch and display related products for each product.

By structuring your backend and frontend in this way, you can effectively manage different collections, popular items, and related products.
